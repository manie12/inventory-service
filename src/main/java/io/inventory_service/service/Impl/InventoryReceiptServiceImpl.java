package io.inventory_service.service.Impl;

import io.inventory_service.config.WebClientFactory;
import io.inventory_service.datatypes.EventType;
import io.inventory_service.datatypes.ReceiptStatus;
import io.inventory_service.dtos.receipt.ReceiptItemDto;
import io.inventory_service.dtos.receipt.StockReceiptCreateRequest;
import io.inventory_service.models.receipt.InventoryReceipt;
import io.inventory_service.models.receipt.InventoryReceiptItem;
import io.inventory_service.repo.receipt.InventoryReceiptItemRepository;
import io.inventory_service.repo.receipt.InventoryReceiptRepository;
import io.inventory_service.service.StockReceiptService;
import io.r2dbc.postgresql.codec.Json;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import org.springframework.kafka.core.KafkaTemplate;

import java.time.Instant;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
@Service
@RequiredArgsConstructor
public class InventoryReceiptServiceImpl implements StockReceiptService {

    private static final String PRODUCT_ENDPOINT = "/products/{sku}";

    private final InventoryReceiptRepository receiptRepo;
    private final InventoryReceiptItemRepository itemRepository;           // for ad-hoc reads
    private final WebClientFactory webClientFactory;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    @Value("${kafka.topics.stock.received.v1}")
    private String stockReceivedTopic;

    @Override
    public Mono<InventoryReceipt> createReceipt(StockReceiptCreateRequest dto, String userId) {

        // 1️⃣  Validate header invariants early
        Assert.notEmpty(dto.items(), "receipt must contain at least one line");

        // 2️⃣  Build header (ID left null → generated by DB)
        InventoryReceipt header = InventoryReceipt.builder()
                .receiptId(dto.receiptCode())
                .warehouseId(dto.warehouseId())
                .supplierId(dto.supplierId())
                .asnId(dto.asnId())
                .receivedByUserId("user1")
                .receiptTimestamp(Instant.now())
                .receiptStatus(ReceiptStatus.DRAFT)
                .externalReferenceId(dto.externalReference())
                .build();
        header.onCreate();

        // 3️⃣  Enrich & map each line → entity
        Mono<List<InventoryReceiptItem>> lineEntitiesMono = Flux.fromIterable(dto.items())
                .flatMap(reqItem -> fetchProductVariantSnapshot(reqItem.sku(), reqItem.variantCode())
                        .map(snapshotJson -> mapToLineEntity(reqItem, snapshotJson)))
                .collectList();

        // 4️⃣  Persist header + lines in single tx
        return lineEntitiesMono.flatMap(items ->
                receiptRepo.insertWithItems(header, items)
                        .doOnSuccess(saved -> publish(stockReceivedTopic, saved, items, EventType.STOCK_RECEIVED_V1))
        );
    }

    /* --- helpers --- */
    private Mono<Json> fetchProductVariantSnapshot(String sku, String variantCode) {
        return webClientFactory.clientFor("product")   // ← logical name
                .get().uri("/products/{sku}", sku)
                .retrieve()
                .bodyToMono(Json.class);
    }

    private InventoryReceiptItem mapToLineEntity(ReceiptItemDto src, Json attrSnapshot) {
        InventoryReceiptItem stockReceiptItem = InventoryReceiptItem.builder()
                .receiptId(null)                           // set later by custom repo
                .sku(src.sku())
                .variantCode(src.variantCode())
                .quantityReceived(src.quantityReceived())
                .purchaseOrderId(src.purchaseOrderId())
                .unitCost(src.unitCost())
                .targetLocationId(src.targetLocationId())
                .batchNo(src.batchNo())
                .build();
        stockReceiptItem.onCreate();
        return stockReceiptItem;
    }

    private void publish(String topic, InventoryReceipt stockReceipt, List<InventoryReceiptItem> stockReceiptItem, EventType eventType) {
        log.info("Publishing {} event for received inventory ID={} to topic={}",
                eventType, stockReceipt.getReceiptId(), topic);
        Map<String, Object> message = new HashMap<>();
        message.put("eventType", eventType);
        message.put("id", stockReceipt.getReceiptId());
        message.put("stockReceipt", stockReceipt);  // Or better: convert to DTO
        message.put("stockReceiptItem", stockReceiptItem);  // Or better: convert to DTO
        try {
            kafkaTemplate.send(topic, message);
            log.info("Successfully published {} event for product ID={}",
                    eventType, stockReceipt.getReceiptId());
        } catch (Exception e) {
            log.error("Failed to publish {} event for product ID={}: {}",
                    eventType, stockReceipt.getReceiptId(), e.getMessage(), e);
            throw e; // Re-throw to let caller handle
        }
    }

}